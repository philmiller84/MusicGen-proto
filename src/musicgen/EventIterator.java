package musicgen;

import static musicgen.PositionType.*;
import static musicgen.Event.*;


//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : MusicGen
//  @ File Name : EventIterator.java
//  @ Date : 6/24/2014
//  @ Author : Phil
//
//


public class EventIterator {
	
    private Event currentEvent;
    private EventLine eventLine;
    private AggregateLine aggregateLine;
    
    public EventIterator(EventLine eventLine)
    {
        this.eventLine = eventLine;
    }
    
    public Event FindEvent(Event event){

        // THIS SHOULD BE MOVED TO AN INNER CLASS, PROBABLY STORAGE. 
        // KEEPING HERE FOR SAKE OF GETTING UP AND RUNNING QUICK. 
        // MOVE IT WHEN THERE IS TIME!

        boolean foundIt = false;
        Event searchEvent = null;
    
        if(event != null)
        {
            searchEvent = eventLine.GetFirstEvent();
            EventNode searchEventNode  = null;
            
            while((searchEvent != null) && (foundIt == false))
            {
                if(searchEvent == event)
                {
                    foundIt = true;
                }
                else
                {
                    searchEventNode = searchEvent.GetContainingNode();
                    
                    searchEventNode = searchEventNode.GetNextNode();
                    searchEvent = searchEventNode.GetEvent();
                }
            }
        }

//        currentEvent = searchEvent;
        return searchEvent;
    }
    
    
    public Event FindCorrespondingEvent(Event event){

        boolean foundIt = false;
        Event searchEvent = null;
    
        if(event != null)
        {
            // REWRITE THIS USING GetByPositionType !!!!
            searchEvent = eventLine.GetFirstEvent();
            EventNode searchEventNode  = null;
            
            while((searchEvent != null) && (foundIt == false))
            {
                if(searchEvent.HasReferenceToEvent(event))
                {
                    foundIt = true;
                }
                else
                {
                    searchEventNode = searchEvent.GetContainingNode();
                    
                    searchEventNode = searchEventNode.GetNextNode();
                    searchEvent = searchEventNode.GetEvent();
                }
            }
        }
//        currentEvent = searchEvent;
        return searchEvent;
    }
    public Event FindCorrespondingEventFromEventLineByPositionType(
            Event relativeEvent, EventLine eventLine, 
            PositionType positionType){
        
        Event searchEvent = null;
        boolean foundIt = false;
        
        this.SetCurrent(relativeEvent);
        
        searchEvent = this.GetByPositionType(positionType);
        
        while(searchEvent != null && foundIt == false){
            
            if(searchEvent.HasReferenceToEventLine(eventLine)){
                foundIt = true;
            }
            else {
                searchEvent = this.GetByPositionType(positionType);
            }
        }
        
        return searchEvent;
    }
    
//    
//    public Event FindCorrespondingEventByPositionType(Event relativeEvent, 
//            PositionType positionType){
//        
//        Event searchEvent = null;
//        boolean foundIt = false;
//        
//        Event aggrSearchEvent = null;
//        aggrSearchEvent = this.FindCorrespondingEvent(relativeEvent);        
//        
//        while(aggrSearchEvent!= null && foundIt == false){
//            
//            this.SetCurrent(aggrSearchEvent);  
//            
//            if(this.GetCurrent().HasReferenceToEventLine(relativeEvent.)){
//                foundIt = true;
//            }
//            else{
//                aggrSearchEvent = this.GetByPositionType(positionType);
//            }
//        }
//        
//        
//        
//        return searchEvent;
//    }
    
    public void CreateEventRelativeToEvent(Event createEvent, 
            Event relativeEvent, PositionType positionType){
        
        // get aggregate line reference
        AggregateLine aggrLineRef = eventLine.GetAggregateLine();
        EventIterator aggrIter = aggrLineRef.GetEventIterator();
        
        // does it need to use current event?
        // if so, why?
        // current event is the event this iterator uses as a relative reference
        // this would provide what? a location, for the created event
        // this location would be where an event would be created
        // but the create event needs a relative event
        // and this relative event would provide the location for the create event
        // since the created event needs to be in relation to the relative event
        
        // find the position of the relative event on the aggregate
        Event aggrSearchEvent = aggrIter.FindCorrespondingEvent(relativeEvent);
        
        aggrSearchEvent = 
                aggrIter.FindCorrespondingEventFromEventLineByPositionType(
                relativeEvent, eventLine, positionType);
                
        if(aggrSearchEvent != null){
            
            Event searchEvent =
                    aggrSearchEvent.GetCorrespondingEventFromEventLine(eventLine);
    
            // current event would need to be located as near the relative event

            // it would need to be inverse to the position type:
            // for something to be created after the relative event,
            // the created event would need to be created before a "current event"
            //     but after a relative event
            PositionType inversePosition = GetInverse(positionType);

            EventIterator targetIter = GetIteratorAtEvent(searchEvent);

            targetIter.CreateEventAtPosition(createEvent, inversePosition);     
        }
        else{
            // if no "current event" is found, then position is irrelative, 
            // beginning or end can be used, should be used???
            
            if(positionType == AFTER ){
                this.CreateEventAtPosition(createEvent, END);
            }
            else if (positionType == BEFORE){
                this.CreateEventAtPosition(createEvent, BEGINNING);
            }
        }
        
        // two operations: aggregate event created after the relative event
        // created event before the "current event" on the target line
    }
    
    
    
    /**
     * CreateEventAtPosition creates the event in the event line, 
     * then adds it to the aggregate line for positioning
     * 
     * This is the method that should be used by the client, whereas Add is to
     * be used for internal data structure operation
     * 
     * @param e
     * @param positionType
     */
    public void CreateEventAtPosition(Event e, PositionType positionType) {
        
        //get aggregate line reference
        AggregateLine aggrLineRef = eventLine.GetAggregateLine();
        
        if ((positionType == AFTER) || 
                (positionType == BEFORE) ||
                (positionType == AT))
        {
            if(currentEvent != null)
            {
                eventLine.InsertRelative(e, currentEvent, positionType);

                //find location in aggregate
                EventIterator aggrIter;
                Event searchEvent;

                aggrIter = aggrLineRef.GetEventIterator();
                searchEvent = aggrIter.FindCorrespondingEvent(currentEvent);
                
                if(searchEvent != null)
                {
                    //call Add on aggregate
                    aggrIter.SetCurrent(searchEvent);
                    if(positionType == AT)
                    {
                        //add reference to current event
                        searchEvent.AddReferenceToEvent(e);
                    }   
                    if((positionType == AFTER)||
                            (positionType == BEFORE))
                    {
                        //create new aggregate
                        AggregateEvent newAggrEvent = new AggregateEvent(e);
                        aggrIter.AddEventAtPosition(newAggrEvent, positionType);
                    }
                }
            }
            else
            {
                //error. WHAT TO DO? Will want to see this fail in testing,
                // but then what use cases would want this to do something?
            }
        }
        else if ((positionType == BEGINNING) || positionType == END)
        {
            eventLine.InsertIrrelative(e, positionType);
            AggregateEvent newAggrEvent = new AggregateEvent(e);
            aggrLineRef.InsertIrrelative(newAggrEvent, positionType);
            
        }
    }
        
    public void AddEventAtPosition(Event e, PositionType positionType) {
        
        if ((positionType == AFTER) || positionType == BEFORE)
        {
            if(currentEvent != null)
            {
                eventLine.InsertRelative(e, currentEvent, positionType);
            }
            else
            {
                //error. WHAT TO DO? Will want to see this fail in testing,
                // but then what use cases would want this to do something?
            }
        }
        else if ((positionType == BEGINNING) || positionType == END)
        {
            eventLine.InsertIrrelative(e, positionType);
        }
        
    }
	
    public void SetCurrent(Event e){
        
        this.currentEvent = e;
    }
    
    public Event GetCurrent(){
        
        return this.currentEvent;
    }
    
    public Event GetByPositionType(PositionType positionType)
    {
        Event searchEvent = null;
        switch(positionType)
        {
            case BEGINNING:
                searchEvent = First();
                break;
            case END:
                searchEvent = Last();
                break;
            case PREV:
            case BEFORE:
                searchEvent = Prev(); 
                break;
            case NEXT:
            case AFTER:
                searchEvent = Next();
                break;
        }
        return searchEvent;
    }
    
    public Event First(){
        if(eventLine != null)
        {
            currentEvent = eventLine.GetFirstEvent();
        }
        return currentEvent;
    }
    
    public Event Last(){
        if(eventLine != null)
        {
            currentEvent = eventLine.GetLastEvent();
        }
        return currentEvent;
    }
    
    public Event Next() {

        if(currentEvent != null)
        {
            EventNode currentEventNode = currentEvent.GetContainingNode();
            EventNode nextEventNode = currentEventNode.GetNextNode();

            if(nextEventNode != null)
                currentEvent = nextEventNode.GetEvent();
            else
                currentEvent = null;
        }
        return currentEvent;
    }
	
    public Event Prev() {
        
        if(currentEvent != null)
        {
            EventNode currentEventNode = currentEvent.GetContainingNode();
            EventNode prevEventNode = currentEventNode.GetPrevNode();
        
            if(prevEventNode != null)
                currentEvent = prevEventNode.GetEvent();
            else
                currentEvent = null;
        }
        return currentEvent;
    }
    
}
